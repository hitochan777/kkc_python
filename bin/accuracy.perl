#!/usr/bin/perl
#=====================================================================================
#                       accuracy.perl
#                             bShinsuke Mori
#                             Last change 9 June 2010
#=====================================================================================

# 機  能 : 仮名漢字変換の精度の計算
#
# 使用法 : accuracy.perl (変換結果ファイル) (正解ファイル)
#
# 実  例 : accuracy.perl T.conv T.sent
#
# 注意点 : 一文が一行に対応していること


#-------------------------------------------------------------------------------------
#                        require
#-------------------------------------------------------------------------------------

use Env;
use File::Basename;
unshift(@INC, dirname($0));

require "Help.pm";


#-------------------------------------------------------------------------------------
#                        check arguments
#-------------------------------------------------------------------------------------

((@ARGV == 2) && ($ARGV[0] ne "-help")) || &Help($0);

($FILE1, $FILE2) = @ARGV;


#-------------------------------------------------------------------------------------
#                        set variable
#-------------------------------------------------------------------------------------

#-------------------------------------------------------------------------------------
#                        initialize
#-------------------------------------------------------------------------------------

open(FILE1) || die "Can't open $FILE1: $!\n";
open(FILE2) || die "Can't open $FILE2: $!\n";


#-------------------------------------------------------------------------------------
#                        main
#-------------------------------------------------------------------------------------

$suc = 0;                                         # マッチした文数
$nm1 = 0;                                         # FILE1 の文字数
$nm2 = 0;                                         # FILE2 の文字数
$nmm = 0;                                         # マッチした文字数
for ($num = 0; (chop($line1 = <FILE1>)) && (chop($line2 = <FILE2>)); $num++){
    $line1 = join("", map((split("/"))[0], split(" ", $line1)));
    $line2 = join("", map((split("/"))[0], split(" ", $line2)));
    $len1 = length($line1)/2;
    $len2 = length($line2)/2;
    $wlcs = &WLCS($line1, $line2);
    $nm1 += $len1;
    $nm2 += $len2;
    $nmm += $wlcs;
    if (($len1 == $wlcs) && ($len2 == $wlcs)){
        $suc++;
#        print $line1, "\n\n\n";
    }else{
        print $., "\n";
        print $line1, "\n";
        print $line2, "\n\n";
    }
}

$FILE1 = basename($FILE1);
$FILE2 = basename($FILE2);
printf("Intersection/%s = %d/%d = %5.2f%%\n", $FILE1, $nmm, $nm1, 100*$nmm/$nm1);
printf("Intersection/%s = %d/%d = %5.2f%%\n", $FILE2, $nmm, $nm2, 100*$nmm/$nm2);
printf("Sentence Accuracy = %d/%d = %5.2f%%\n", $suc, $num, 100*$suc/$num);


#-------------------------------------------------------------------------------------
#                        close
#-------------------------------------------------------------------------------------

close(FILE1);
close(FILE2);
exit(0);


#-------------------------------------------------------------------------------------
#                        WLCS
#-------------------------------------------------------------------------------------

sub WLCS{
    ($str1, $str2) = @_;

    ($len1, $len2) = (length($str1)/2, length($str2)/2);

    @DP = ([(0) x $len2+1]) x $len1+1;

#    print scalar(@DP), "\n";

    for ($pos1 = 1; $pos1 <= $len1; $pos1++){
        for ($pos2 = 1; $pos2 <= $len2; $pos2++){
            if (substr($str1, ($pos1-1)*2, 2) eq substr($str2, ($pos2-1)*2, 2)){
                $DP[$pos1][$pos2] = $DP[$pos1-1][$pos2-1]+1;
            }else{
                $DP[$pos1][$pos2] = &max($DP[$pos1-1][$pos2], $DP[$pos1][$pos2-1]);
            }
        }
    }

    return($DP[$len1][$len2]);
}


#-------------------------------------------------------------------------------------
#                        max
#-------------------------------------------------------------------------------------

sub max{
    my($max) = shift(@_);

    foreach (@_){
        ($_ > $max) && ($max = $_);
    }
    
    return($max);
}


#=====================================================================================
#                        END
#=====================================================================================
